# Programming Assignment: Support Vector Machines

### 1 Support Vector Machines



### 1.1 Example Dataset 1



### 1.2 SVM with Gaussian Kernels



### 2 Spam Classification



### 2.1 Preprocessing Emails



### 2.2 Extracting Features from Emails



### 2.3 Training SVM for Spam Classification



### 2.4 Top Predictors for Spam



### 2.5 Try your own emails (optional)



### 2.6 Build your own dataset (optional)



### Programming Ex.6



### Ex6 Tutorials

Here are the ex6 tutorials by Tom Mosher:

__gaussianKernel()__:

The numerator is the sum of the squares of the difference of two vectors. That's similar to how you computed the linear regression cost function in ex1. Then use exp() with scaling based on the 'sigma' parameter, according to the kernel formula.

dataset3Params():

One method is to use two nested for-loops - each one iterating over the range of C or sigma values given in the ex6.pdf file.

Inside the inner loop:

+ Train the model using svmTrain with X, y, a value for C, and the gaussian kernel using a value for sigma. See ex6.m at line 108 for an example of the correct syntax to use in calling svmTrain() and the gaussian kernel. Note: Use temporary variables for C and sigma when you call svmTrain(). Only use 'C' and 'sigma' for the final values you are going to return from the function.
+ Compute the predictions for the validation set using svmPredict() with model and Xval.
+ Compute the error between your predictions and yval.
+ When you find a new minimum error, save the C and sigma values that were used. Or, for each error computation, you can save the C, sigma, and error values as rows of a matrix. When all 64 computations are completed, use min() to find the row with the minimum error, then use that row index to retrieve the C and sigma values that produced the minimum error.
Sample code structure for dataset3Params():

```matlab
results = []   % create an empty results matrix

for C_test = [list of values here]
    for sigma_test = [list of values here]

        % your code goes here to train using C_test and sigma_test
        %    and compute the validation set errors

        % save the results in the matrix
        results = [results ; C_test sigma_test err_value]

    endfor
endfor

% use the min() function to find the best C and sigma values
```

Here is an example of how to find the values in the row of a matrix Q that has the lowest value in column 3:

```matlab
>> Q = rand(6,3)
Q =

   0.3840651   0.0738230   0.7128092
   0.4558660   0.6360802   0.7075968
   0.3822171   0.4430273   0.6626950
   0.0090786   0.1231786   0.4371842
   0.5808400   0.0045790   0.6251304
   0.8679802   0.0193655   0.1613009

>> [v i] = min(Q(:,3))
v =  0.16130
i =  6

>> Q(i,1)
ans =  0.86798

>> Q(i,2)
ans =  0.019366
```

---------------------------------------

__processEmail()__:

To see what variables already exist in processEmail.m, you can set a breakpoint in the processEmail.m script template in the blank area below the "YOUR CODE HERE" comment block. Use the breakpoint tool in the GUI code editor. Then run the ex6_spam script from the console.

When program execution hits the breakpoint, it will activate the console in debug mode. There you can inspect the variables "str" and "vocabList" (type the variable name into the console and press `<Enter>`).

Observe that str holds a single word, and that vocabList is a cell array of all known words. Resume execution with the 'return' command in the debugger.

For the code you need to add:

Here is an example using the `strcmp()` function showing how to find the index of a word in a cell array of words:

```matlab
small_list = {'alpha', 'bravo', 'charlie', 'delta', 'echo'}
match = strcmp('bravo', small_list)
find(match)
```

`strcmp()` returns a logical vector, with a 1 marking each location where a word occurs in the list. If there is no match, all of the logical values are 0's.

The `find()` function returns a list of the non-zero elements in "match". You can add these index values to the word_indices list by concatenation.

Note that if there is no match, `find()` returns a null vector, and this can be concatenated to the word list without any problems.

Note that your word_index list must be returned as a column vector. If you make it a row vector, the submit grader will still give you credit, but your emailFeatures() function will not work correctly.

-------------------------------------

__emailFeatures__:

The `emailFeatures()` function is one of the simplest in the entire course:

+ You're given a list of word indexes.
+ For each index in that list, you're asked to set the corresponding entries in an 'x' array to the value '1'.

A couple of different methods could be used:

+ Loop through the list of word indexes, and use each index to set the corresponding value in the 'x' array to 1.
+ Take advantage of vectorized indexing, and do the same operation in one line of code without the loop.

Note that the 'x' feature list must be a column vector, and the word_indices list (which is provided by your processEmail() function) must be a column vector.

You can complete this function by adding only one line of code.Try this example in your console:

```matlab
vec = zeros(10,1)     % included in the function template
indexes = [1 3 5]     % you're provided with a list of indexes
vec(indexes) = 1      % set the values to 1
```

------------------------------------

How do I install and use LIBSVM?

See [this page](https://www.coursera.org/learn/machine-learning/resources/TEPQT)



